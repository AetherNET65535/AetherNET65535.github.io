+++
title = "XV6-2020 LAB1-UTIL"
date = 2025-06-04
draft = false
[taxonomies]
tags = ["xv6"]
[extra]
toc = true
display_published = true 
author = "aethernet"
+++
事先声明，我写的博客，操作基本都是在ARCH LINUX上实现的。

这是XV6-2020的第一个LAB，主要是初步认识RISC-V版的XV6，然后为其实现一些用户态的小工具。

## boot xv6 (easy)
首先，先下载git，再clone下来xv6-labs-2020的文件。
```sh
sudo -S pacman git

git clone git://g.csail.mit.edu/xv6/labs-2020
cd xv6-labs-2020
git checkout util
make clean && make qemu
```

<br>

> 如果跑不了的话，可能是因为你的QEMU太新了，也有可能是其它问题。你可以试试给QEMU降级，或者去学习使用PODMAN或DOCKER（并不难）。

## sleep (easy)

在user目录里，创建名为sleep.c的文件。
```tree
xv6-labs-2020/
|-- user/
|-- |-- sleep.c
```

调用sleep系统调用来实现这个功能。
```C
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main (int argc, char *argv[])
{
    // 参数是否为2个？例子：sleep 10
    if (argc != 2)
    {
        fprintf (2, "usage: sleep <ticks>\n");
        exit(1);
    }
    
    // 把ASCII转为INT
    int ticks = atoi(argv[1]);
    // int adjusted_ticks = ticks * 10; 这个别抄，作用是把CPU TICKS换成秒数 
    
    // 如果用户输入的TICKS小于0，那就改为0（毕竟总不可能给你来个时间倒流）
    if (adjusted_ticks < 0)
    {
        adjusted_ticks = 0;
    }

    sleep(adjusted_ticks); // 这里就是调用sleep，xv6已经写好sleep的实现了

    exit(0);
}
```

在Makefile的UPROGS处添加$U/_sleep\
```Makefile
UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_sleep\ # 加上这个
```

## pingpong (easy)

和上一个一样，先在user目录里创建pingpong.c文件。

```tree
xv6-labs-2020/
|-- user/
|-- |-- sleep.c
|-- |-- pingpong.c
```

<br>

```C
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

// 给文件描述符起个更直观的别名	
#define READ 0
#define WRITE 1

int main (int argc, char *argv[])
{
    if (argc != 1)
    {
        fprintf(2, "usage: pingpong\n");
        exit(1);
    }

    int pid, p2c[2], c2p[2];
    char signal = 0; 
    
    pipe(p2c); // 创建P2C管道，简称P（PARENT）
    pipe(c2p); // 创建C2P管道，简称C（CHILD）

    if ((pid = fork()) > 0) // 父进程
    {
		// 父进程只需要写P2C，读C2P
        close(p2c[READ]);  
        close(c2p[WRITE]); 

		// 发球：向子进程发送一个字节（触发子进程的read）
        write(p2c[WRITE], &signal, 1); 
		close(p2c[WRITE]); 

		// 等待接球：阻塞直到读取子进程的返回信号
        read(c2p[READ], &signal, 1); 
		close(c2p[READ]); 

        printf("%d: Received Pong\n", getpid());
        
        exit(0); // 关闭程序
    }
    else if (pid == 0) // 子进程
    {
		// 子进程只需要读P2C，写C2P
        close(c2p[READ]); 
        close(p2c[WRITE]); 

		// 等待接球：阻塞直到读取父进程的信号
        read(p2c[READ], &signal, 1); 
        close(p2c[READ]);

        printf("%d: Received Ping\n", getpid());
        
		// 回球：向父进程返回一个字节
        write(c2p[WRITE], &signal, 1); 
        close(c2p[WRITE]); 

        exit(0); // 关闭子进程
    }
    else
    {
        fprintf(2, "fork error\n");
        exit(1);
    }
}
```
上面的代码你可能看不懂，让我解释解释。
<br>
首先，当我们当前的进程`fork`出了一个子进程后，这两个进程是并行的，就是他们是同时跑的。
<br>
但是我们希望这个代码是有顺序的，所以我们需要让其中一个不能跑。
<br>
我们在这里利用的是管道的堵塞机制，即“如果读取不到，就不执行下一个代码”。

用乒乓球举例（我没打过，也不了解乒乓球）
<br>
乒乓球的桌子，上面有两个区域，一个是P区域，一个是C区域。
<br>
父亲站在P那里，他只可以把球打过去C那里，或者抓住飞到P区域的球。
<br>
一样的，儿子只能站在C那里，他只能把球打去P区域，或者抓住飞到C区域的球。

当父亲还没有把球打给儿子时，儿子就不能抓住球，因为球没有飞向他。

### 常见疑问
Q: 为什么需要两个管道？  
A: 管道是单向的，要实现双向通信必须用两个管道。

Q: `signal`的作用是什么？  
A: 实际不需要传输有效数据，只需通过管道的**存在性**触发同步。

Q: 不关闭未使用的描述符会怎样？  
A: 可能导致——子进程的`read`无法收到EOF（因为父进程的写入端未关闭）
